//*************************************************************************
//Thanks for the code reference game4automation provides.                 *
//                                                                        *
//*************************************************************************
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using NaughtyAttributes;
using System;
using RDTS.Method;

namespace RDTS
{
    [System.Serializable]
    public class EventMUCreated : UnityEvent<MU>
    {
    }

    /// <summary>
    /// 提供产生MU对象的方法：
    ///     信号控制（false变为true）产生；
    ///     达到给定距离自动产生；
    ///     间隔时间产生。
    /// 记录产生的MU，可控制信号删除。
    /// 可限定产生的数量。
    /// </summary>
    [SelectionBase]
    //! The Source is generating MUs during simulation time. 仿真时产生MU
    //! The Source is generating new MUs based on the referenced (ThisObjectAsMU) GameObject.  
    //! When generating an MU a copy of the referenced GameObject will be created.
    public class Source : BaseSource, IValueInterface
    {
        // Public / UI Variablies
        [Header("General Settings")] public GameObject ThisObjectAsMU; //!< The referenced GameObject which should be used as a prototype for the MU. If it is null it will be this GameObject. MU的原型，为Null时即为此gameobject
        public GameObject Destination; //!< The destination GameObject where the generated MU should be placed  产生的MU的父对象
        public bool Enabled = true; //!< If set to true the Source is enabled  启动Source的产生功能
        public bool FreezeSourcePosition = true; //!< If set to true the Source itself (the MU template) is fixed to its position  是否固定Source的位置
        public bool DontVisualize = true; //!< True if the Source should not be visible during Simulation time  是否在仿真时隐藏Source
        public bool IsVisible = false;//是否在仿真时隐藏源Source
        public float Mass = 1; //!< Mass of the generated MU.生成的 MU 的质量
        public bool SetCenterOfMass = false;//是否设置MU的质心
        public Vector3 CenterOfMass = new Vector3(0, 0, 0); //!< Mass of the generated MU. MU的质心
       // public string GenerateOnLayer = ""; //! Layer where the MUs should be generated to - if kept empty no layers are changed 产生的MU应被定义的层级
        public RDTSLayer GenerateOnLayer = RDTSLayer.None;
        [HideInInspector] public bool ChangeDefaultLayer = true;  //! If set to true Layers are automatically changed if default Layer is detected  如果设置为 true，如果检测到默认图层，图层将自动更改
        [ReorderableList] public List<string> OnCreateDestroyComponents = new List<string>(); //! Destroy this components on MU when MU is created as a copy of the source - is used to delete additional source scripts  销毁产生的MU上的组件
        [Header("Create in Inverval (0 if not)")]
        public float StartInterval = 0; //! Start MU creation with the given seconds after simulation start   仿真运行后，在给定的秒数过后开始创建MU
        public float Interval = 0; //! Interval in seconds between the generation of MUs. Needs to be set to 0 if no interval generation is wished.  MU生成之间的时间间隔（以秒为单位）。如果不希望生成间隔，则需要设置为 0。

        [Header("Automatic Generation on Distance")]
        public bool AutomaticGeneration = true; //! Automatic generation of MUs if last MU is above the GenerateIfDistance distance from MU  如果与上一个MU的距离大于GenerateIfDistance设定的距离，则自动生成MU
        public float GenerateIfDistance = 300; //! Distance in millimeters from Source when new MUs should be generated. 应生成新 MU 时与 Source 的距离（以毫米为单位）。

        [Header("Number of MUs")] public bool LimitNumber = false;//是否限制个数
        public int MaxNumberMUs = 1;
        [ReadOnly] public int Created = 0;//记录产生的MU的个数

        [Header("Source IO's")] public bool GenerateMU = true; //! When changing from false to true a new MU is generated.   该位从false变为true则产生一个MU
        public bool DeleteAllMU; //! when changing from false to true all MUs generated by this Source are deleted.   该位从false变为true则销毁所有产生的MU

        [Header("Source Signals")] public ValueOutputBool SourceGenerate; //! When changing from false to true a new MU is generated.   Value信号：从false变为true则产生一个MU

        [Header("Events")]
        public EventMUCreated
            EventMUCreated;

        // Private Variablies
        private bool _generatebefore = false;
        private bool _deleteallmusbefore = false;
        private bool _tmpoccupied;
        private GameObject _lastgenerated;
        private int ID = 0;
        private bool _generatenotnull = false;//PLC信号是否为null
        [ReadOnly]public List<GameObject> _generated = new List<GameObject>();//记录产生的MU对象

        protected void Reset()
        {
            if (ThisObjectAsMU == null)
            {
                ThisObjectAsMU = gameObject;//未设定MU原型，则选择此gameobject作为原型(模板)
            }
        }

        protected void Start()
        {
            //判断PLC信号是否存在
            if (SourceGenerate != null)
                _generatenotnull = true;

            if (ThisObjectAsMU == null)
            {
                ErrorMessage("Object to be created needs to be defined in [This Object As MU]");
            }

            if (ThisObjectAsMU != null)
            {
                if (ThisObjectAsMU.GetComponent<MU>() == null)
                {
                    ThisObjectAsMU.AddComponent<MU>();//若原型不附带MU脚本，就添加
                }
            }

            if (Interval > 0)
            {
                InvokeRepeating("Generate", StartInterval, Interval);//在 StartInterval 秒后调用 Generate 方法，然后每 Interval 秒调用一次
            }

            SetVisibility(!DontVisualize);//是否隐藏MU原型
            SetCollider(false);//停用Collider
            SetFreezePosition(FreezeSourcePosition);//是否需要冻结MU原型

            if (GetComponent<Collider>() != null)
            {
                GetComponent<Collider>().enabled = false;
            }
        }


        private void Update()
        {
            if (_generatenotnull)
                GenerateMU = SourceGenerate.Value;

            // Generate on Signal Genarate MU
            //信号值变化产生一个MU
            if (_generatebefore != GenerateMU)
            {
                if (GenerateMU)
                {
                    _generatebefore = GenerateMU;
                    Generate();
                }
            }

            // Generate if Distance
            //若开启了“自动产生模式”，当距离缠裹给定值时则产生一个MU
            if (AutomaticGeneration)
            {
                if (_lastgenerated != null)
                {
                    float distance = Vector3.Distance(_lastgenerated.transform.position, gameObject.transform.position) *
                                     RDTSController.Scale;

                    if (distance > GenerateIfDistance)
                    {
                        Generate();
                    }
                }
            }

            // Generate on Keypressed
            //使用控制器中定义的快捷键来产生一个MU
            if (Input.GetKeyDown(RDTSController.HotkeyCreateOnSource))
            {
                Generate();
            }

            if (GenerateMU == false)
            {
                _generatebefore = false;
            }

            //删除产生的MU
            if (DeleteAllMU != _deleteallmusbefore && DeleteAllMU == true)
            {
                DeleteAll();
            }


            // Delete  on Keypressed
            //使用控制器中定义的快捷键来删除MU
            if (Input.GetKeyDown(RDTSController.HotkeyDelete))
            {
                if (RDTSController.EnableHotkeys)
                    DeleteAll();
            }


            _deleteallmusbefore = DeleteAllMU;
        }

        //! Generates an MU.
        /// <summary>
        /// 之后用对象池替代，将GetComponentInChildren全部在Start函数中率先记录
        /// </summary>
        /// <returns>返回产生的NMU</returns>
        public MU Generate()
        {
            //若置位“限制个数”，且产生的MU个数已达到最大限制数量，则不在产生MU
            if (LimitNumber && (Created >= MaxNumberMUs))
                return null;

            if (Enabled)//开启了Source的功能
            {
                GameObject newmu = GameObject.Instantiate(ThisObjectAsMU, transform.position, transform.rotation);
                if(IsVisible==true)
                    Global.SetVisible((GameObject)ThisObjectAsMU, false);
                

                //设置产生MU的层级
                string layer = GenerateOnLayer.ToString();
                if (layer != RDTSLayer.None.ToString())
                {
                    if (LayerMask.NameToLayer(layer) != -1)
                    {
                        newmu.layer = LayerMask.NameToLayer(layer);
                    }
                }

                if (ChangeDefaultLayer)
                {
                    /// Check if still default layer -- if yes then set box collider to g4a MU
                    var box = newmu.GetComponentInChildren<BoxCollider>();
                    if (box != null)
                    {
                        if (box.gameObject.layer == LayerMask.NameToLayer("Default"))
                            box.gameObject.layer = LayerMask.NameToLayer(RDTSLayer.MU.ToString());
                    }

                    var mesh = newmu.GetComponentInChildren<MeshCollider>();
                    if (mesh != null)
                    {
                        if (mesh.gameObject.layer == LayerMask.NameToLayer("Default"))
                            mesh.gameObject.layer = LayerMask.NameToLayer(RDTSLayer.TransportMU.ToString());
                    }
                }

                Source source = newmu.GetComponent<Source>();

                Created++;//记录产生的MU数量

                Rigidbody newrigid = newmu.GetComponentInChildren<Rigidbody>();
                if (newrigid == null)
                {
                    newrigid = newmu.AddComponent<Rigidbody>();
                }

                newrigid.mass = Mass;

                BoxCollider newboxcollider = newmu.GetComponentInChildren<BoxCollider>();
                if (newboxcollider == null)//如果创建的MU没有BoxCollider，则根据网格的中心和尺寸创建一个合适的BoxCollider
                {
                    newboxcollider = newmu.AddComponent<BoxCollider>();
                    MeshFilter mumsmeshfilter = newmu.GetComponentInChildren<MeshFilter>();
                    Mesh mumesh = mumsmeshfilter.mesh;
                    GameObject obj = mumsmeshfilter.gameObject;
                    if (mumesh != null)
                    {
                        Vector3 globalcenter = obj.transform.TransformPoint(mumesh.bounds.center);
                        Vector3 globalsize = obj.transform.TransformVector(mumesh.bounds.size);//size.x 为盒体的宽度，size.y 为高度，size.z 为深度
                        newboxcollider.center = newmu.transform.InverseTransformPoint(globalcenter);
                        Vector3 size = newmu.transform.InverseTransformVector(globalsize);
                        if (size.x < 0)
                        {
                            size.x = -size.x;
                        }

                        if (size.y < 0)
                        {
                            size.y = -size.y;
                        }

                        if (size.z < 0)
                        {
                            size.z = -size.z;
                        }

                        newboxcollider.size = size;
                    }
                }
                else
                {
                    newboxcollider.enabled = true;
                }

                newrigid.mass = Mass;
                if (SetCenterOfMass)
                    newrigid.centerOfMass = CenterOfMass;
                source.SetVisibility(true);
                source.SetCollider(true);
                source.SetFreezePosition(false);

                source.Enabled = false;
                source.enabled = false;
                ID++;
                MU mu = newmu.GetComponent<MU>();
                if (Destination != null)//Destination不为空，则设置Destination为父对象
                {
                    newmu.transform.parent = Destination.transform;
                }

                if (mu == null)
                {
                    ErrorMessage("Object generated by source need to have MU script attached!");
                }
                else
                {
                    var name = ThisObjectAsMU.name + "-" + ID.ToString();//设置名称
                    mu.InitMu(name, ID, RDTSController.GetMUID(newmu));//初始化MU的名称和ID

                }

                Destroy(source);//销毁source
                // Destroy Additional Components 销毁额外输入的组件
                foreach (var componentname in OnCreateDestroyComponents)
                {

                    Component[] components = newmu.GetComponents(typeof(Component));
                    foreach (Component component in components)
                    {
                        var ty = component.GetType();
                        if (ty.ToString() == componentname)
                            Destroy(component);
                    }


                }

                _lastgenerated = newmu;
                _generated.Add(newmu);//加入产生MU的列表
                EventMUCreated.Invoke(mu);//调用Event方法
                var isources = newmu.GetComponents<ISourceCreated>();
                foreach (var isource in isources)
                {
                    isource.OnSourceCreated();
                }
                return mu;
            }

            return null;
        }

        //! Deletes all MU generated by this Source
        /// <summary>
        /// 销毁所有产生的MU对象
        /// </summary>
        public void DeleteAll()
        {
            foreach (GameObject obj in _generated)
            {
                Destroy(obj);
            }

            _generated.Clear();
        }
    }
}